/* ============================================================================
 * Copyright (c) 2009-2016 BlueQuartz Software, LLC
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright notice, this
 * list of conditions and the following disclaimer in the documentation and/or
 * other materials provided with the distribution.
 *
 * Neither the name of BlueQuartz Software, the US Air Force, nor the names of its
 * contributors may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The code contained herein was partially funded by the followig contracts:
 *    United States Air Force Prime Contract FA8650-07-D-5800
 *    United States Air Force Prime Contract FA8650-10-D-5210
 *    United States Prime Contract Navy N00173-07-C-2068
 *
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "StatsGenRDFWidget.h"

//-- C++ Includes
#include <iostream>

//-- Qt Includes
#include <QtConcurrent/QtConcurrentMap>
#include <QtCore/QDir>
#include <QtCore/QFile>
#include <QtCore/QFileInfo>
#include <QtCore/QSettings>
#include <QtCore/QString>
#include <QtCore/QVector>
#include <QtGui/QCloseEvent>
#include <QtWidgets/QAbstractItemDelegate>
#include <QtWidgets/QFileDialog>
#include <QtWidgets/QMessageBox>

#include "SIMPLib/Math/RadialDistributionFunction.h"
#include "SVWidgetsLib/Widgets/SVStyle.h"

#include "SyntheticBuilding/Gui/Widgets/TableModels/SGMDFTableModel.h"
#include "SyntheticBuilding/SyntheticBuildingConstants.h"

//-- Qwt Includes AFTER SIMPLib Math due to improper defines in qwt_plot_curve.h
#include <qwt.h>
#include <qwt_abstract_scale_draw.h>
#include <qwt_compat.h>
#include <qwt_interval.h>
#include <qwt_picker_machine.h>
#include <qwt_plot.h>
#include <qwt_plot_canvas.h>
#include <qwt_plot_curve.h>
#include <qwt_plot_grid.h>
#include <qwt_plot_layout.h>
#include <qwt_plot_marker.h>
#include <qwt_plot_picker.h>
#include <qwt_plot_shapeitem.h>
#include <qwt_scale_widget.h>
#include <qwt_symbol.h>

// Include the header file generated by UIC
#include "ui_StatsGenRDFWidget.h"

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
StatsGenRDFWidget::StatsGenRDFWidget(QWidget* parent)
: QWidget(parent)
, ui(new Ui::StatsGenRDFWidget)
, m_RDFTableModel(nullptr)
{
  ui->setupUi(this);
  this->setupGui();
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
StatsGenRDFWidget::~StatsGenRDFWidget()
{
  if(nullptr != m_RDFTableModel)
  {
    m_RDFTableModel->deleteLater();
  }
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
SGRDFTableModel* StatsGenRDFWidget::tableModel()
{
  return m_RDFTableModel;
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
void StatsGenRDFWidget::setupGui()
{
  initQwtPlot("Radial Distribution Plot", "Freq", ui->m_RDFPlot);
  m_RDFTableModel = new SGRDFTableModel;
  m_RDFTableModel->setInitialValues();
  ui->m_RDFTableView->setModel(m_RDFTableModel);
  QAbstractItemDelegate* aid = m_RDFTableModel->getItemDelegate();
  ui->m_RDFTableView->setItemDelegate(aid);
  ui->warningMessage->setText("");
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
void StatsGenRDFWidget::initQwtPlot(QString xAxisName, QString yAxisName, QwtPlot* plot)
{


  QPalette pal;
  pal.setColor(QPalette::Text, SVStyle::Instance()->getQLabel_color());
  pal.setColor(QPalette::Foreground, Qt::white);
  pal.setColor(QPalette::Window, Qt::black);

  plot->setPalette(pal);

  plot->plotLayout()->setAlignCanvasToScales(true);
  for(int axis = 0; axis < QwtPlot::axisCnt; axis++)
  {
    plot->axisWidget(axis)->setMargin(0);
    plot->axisWidget(axis)->setPalette(pal);
  }

  QwtPlotCanvas* canvas = new QwtPlotCanvas();

  canvas->setAutoFillBackground(false);
  canvas->setFrameStyle(QFrame::NoFrame);
  canvas->setPalette(pal);
  plot->setCanvas(canvas);

  QFont font = SVStyle::Instance()->GetUIFont();
  font.setWeight(QFont::Bold);
  font.setPointSize(SG_FONT_SIZE);

  QwtText xAxis(xAxisName);
  xAxis.setRenderFlags(Qt::AlignHCenter | Qt::AlignTop);
  xAxis.setFont(font);
  xAxis.setColor(SVStyle::Instance()->getQLabel_color());
  plot->setAxisTitle(QwtPlot::xBottom, xAxisName);

  QwtText yAxis(yAxisName);
  yAxis.setRenderFlags(Qt::AlignHCenter | Qt::AlignTop);
  yAxis.setFont(font);
  yAxis.setColor(SVStyle::Instance()->getQLabel_color());
  plot->setAxisTitle(QwtPlot::yLeft, yAxisName);

  const int margin = 0;
  plot->setContentsMargins(margin, margin, margin, margin);

  QwtPlotPicker* plotPicker = new QwtPlotPicker(plot->xBottom, plot->yLeft, QwtPicker::CrossRubberBand, QwtPicker::AlwaysOn, plot->canvas());
  QwtPickerMachine* pickerMachine = new QwtPickerClickPointMachine();
  plotPicker->setTrackerPen(QPen(SVStyle::Instance()->getQLabel_color()));
  plotPicker->setStateMachine(pickerMachine);

  m_PlotCurve = new QwtPlotCurve();
  m_PlotCurve->setStyle(QwtPlotCurve::Lines);
  // Use Antialiasing to improve plot render quality
  m_PlotCurve->setRenderHint(QwtPlotItem::RenderAntialiased, true);
  QPen pen;
  pen.setColor(SVStyle::Instance()->getQLabel_color());
  pen.setWidth(2);
  m_PlotCurve->setPen(pen); // Set color and thickness for drawing the curve
  m_PlotCurve->attach(plot);
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
void StatsGenRDFWidget::on_generateRDFBtn_clicked()
{
  QLocale loc = QLocale::system();
  // Generate the ODF Data from the current values in the ODFTableModel
  bool ok = false;
  ok = validateInput();
  if(!ok)
  {
    // Update the Table model with the latest values
    QVector<float> qFreq(1, 0);
    m_RDFTableModel->setTableData(qFreq);
    // Update the Qwt plot with the correct values
    updateRDFPlot(qFreq);
    return;
  }
  ui->warningMessage->setText(QString(""));
  float minDist = loc.toFloat(ui->minDistLE->text(), &ok);
  float maxDist = loc.toFloat(ui->maxDistLE->text(), &ok);
  int numBins = ui->numBinsLE->text().toInt(&ok);

  std::vector<float> boxDims(3);
  boxDims[0] = loc.toFloat(ui->BoxSizeXLE->text(), &ok);
  boxDims[1] = loc.toFloat(ui->BoxSizeYLE->text(), &ok);
  boxDims[2] = loc.toFloat(ui->BoxSizeZLE->text(), &ok);
  std::vector<float> boxRes(3);
  boxRes[0] = 0.1f;
  boxRes[1] = 0.1f;
  boxRes[2] = 0.1f;

  // Generate the RDF Frequencies
  std::vector<float> rdfFrequencies = RadialDistributionFunction::GenerateRandomDistribution(minDist, maxDist, numBins, boxDims, boxRes);
  QVector<float> qFreq = QVector<float>::fromStdVector(rdfFrequencies);

  // Update the Table model with the latest values
  m_RDFTableModel->setTableData(qFreq);

  // Update the Qwt plot with the correct values
  updateRDFPlot(qFreq);

  emit rdfParametersChanged();
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
bool StatsGenRDFWidget::validateInput()
{
  bool isValid = false;

  float minDist = ui->minDistLE->text().toFloat(&isValid);
  if(!isValid)
  {
    ui->warningMessage->setText(QString("Minimum Distance is not valid"));
    return isValid;
  }
  if(minDist <= 0)
  {
    ui->warningMessage->setText(QString("Min distance must be > Zero"));
    return false;
  }

  float maxDist = ui->maxDistLE->text().toFloat(&isValid);
  if(!isValid)
  {
    ui->warningMessage->setText(QString("Maximum Distance is not valid"));
    return isValid;
  }
  if(maxDist <= 0)
  {
    ui->warningMessage->setText(QString("Max distance must be > Zero"));
    return false;
  }

  float xBox = ui->BoxSizeXLE->text().toFloat(&isValid);
  if(!isValid)
  {
    ui->warningMessage->setText(QString("X Box Size is not valid"));
    return isValid;
  }
  if(xBox <= 0)
  {
    ui->warningMessage->setText(QString("X Box Size must be > Zero"));
    return false;
  }

  float yBox = ui->BoxSizeYLE->text().toFloat(&isValid);
  if(!isValid)
  {
    ui->warningMessage->setText(QString("Y Box Size is not valid"));
    return isValid;
  }
  if(yBox <= 0)
  {
    ui->warningMessage->setText(QString("Y Box Size must be > Zero"));
    return false;
  }

  float zBox = ui->BoxSizeZLE->text().toFloat(&isValid);
  if(!isValid)
  {
    ui->warningMessage->setText(QString("Z Box Size is not valid"));
    return isValid;
  }
  if(zBox <= 0)
  {
    ui->warningMessage->setText(QString("Z Box Size must be > Zero"));
    return false;
  }

  int numBins = ui->numBinsLE->text().toInt(&isValid);
  if(!isValid)
  {
    ui->warningMessage->setText(QString("Number of Bins is not valid"));
    return isValid;
  }
  if(numBins < 0)
  {
    ui->warningMessage->setText(QString("Number of Bins is less than Zero"));
    return false;
  }

  if(minDist >= maxDist)
  {
    ui->warningMessage->setText(QString("Max distance is less than Min distance"));
    isValid = false;
  }

  return isValid;
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
void StatsGenRDFWidget::updateRDFPlot(QVector<float>& freqs)
{
  // These are the output vectors
  QwtArray<double> xD(static_cast<int>(freqs.size()));
  QwtArray<double> yD(static_cast<int>(freqs.size()));

  QLocale loc = QLocale::system();

  bool ok = false;
  float minDist = loc.toFloat(ui->minDistLE->text(), &ok);
  float maxDist = loc.toFloat(ui->maxDistLE->text(), &ok);

  const int numValues = freqs.size();
  float increment = (maxDist - minDist) / numValues;

  double pos = minDist;

  for(qint32 i = 0; i < numValues; ++i)
  {
    xD[i] = pos;
    yD[i] = static_cast<double>(freqs.at(i));
    pos = pos + increment;
  }

  // This will actually plot the XY data in the Qwt plot widget
  QwtPlotCurve* curve = m_PlotCurve;
#if QWT_VERSION >= 0x060000
  curve->setSamples(xD, yD);
#else
  curve->setData(xD, yD);
#endif

  QColor color = QColor("DodgerBlue");
  curve->setPen(color, 2);
  curve->setRenderHint(QwtPlotItem::RenderAntialiased, true);
  curve->setStyle(QwtPlotCurve::Lines);

  ui->m_RDFPlot->replot();
  ui->m_RDFPlot->update();
  this->repaint();
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
void StatsGenRDFWidget::updatePlots()
{
  on_generateRDFBtn_clicked();
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
void StatsGenRDFWidget::extractStatsData(int index, StatsData* statsData, PhaseType::Type phaseType)
{
  Q_UNUSED(index)
  if(phaseType == PhaseType::Type::Precipitate)
  {
    PrecipitateStatsData* pp = dynamic_cast<PrecipitateStatsData*>(statsData);
    //    arrays = pp->getMDF_Weights();
    RdfData::Pointer rdf = pp->getRadialDistFunction();
    if(nullptr != rdf.get())
    {
      float boxDim[3];
      rdf->getBoxSize(boxDim);
      ui->BoxSizeXLE->setText(QString::number(boxDim[0]));
      ui->BoxSizeYLE->setText(QString::number(boxDim[1]));
      ui->BoxSizeZLE->setText(QString::number(boxDim[2]));

      float boxRes[3];
      rdf->getBoxResolution(boxRes);

      ui->minDistLE->setText(QString::number(rdf->getMinDistance()));
      ui->maxDistLE->setText(QString::number(rdf->getMaxDistance()));
      ui->numBinsLE->setText(QString::number(rdf->getNumberOfBins()));

      // Generate a new RDF for these
      // on_generateRDFBtn_clicked();
    }
  }

  // Generate the RDF table Plot? which adds value to the Table?
  on_generateRDFBtn_clicked();
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
RdfData::Pointer StatsGenRDFWidget::getStatisticsData()
{
  bool ok = false;
  RdfData::Pointer rdf = RdfData::New();
  QVector<float> qRdfDataFinal(ui->numBinsLE->text().toInt(&ok));
  rdf->setNumberOfBins(ui->numBinsLE->text().toInt(&ok));

  QLocale loc = QLocale::system();
  std::vector<float> boxDims(3);
  boxDims[0] = loc.toFloat(ui->BoxSizeXLE->text(), &ok);
  boxDims[1] = loc.toFloat(ui->BoxSizeYLE->text(), &ok);
  boxDims[2] = loc.toFloat(ui->BoxSizeZLE->text(), &ok);
  rdf->setBoxSize(boxDims.data());

  std::vector<float> boxRes(3);
  boxRes[0] = 0.1f;
  boxRes[1] = 0.1f;
  boxRes[2] = 0.1f;
  rdf->setBoxResolution(boxRes.data());

  float minDist = loc.toFloat(ui->minDistLE->text(), &ok);
  float maxDist = loc.toFloat(ui->maxDistLE->text(), &ok);

  rdf->setMinDistance(minDist);
  rdf->setMaxDistance(maxDist);

  // Here we want to take whatever the user entered in and normalize
  // it by what it would look like if a large number of particles were
  // randomly thrown in the same size box.
  // So, for example, if the user chooses a random distribution to start with
  // the actual values they would store would be very close to 1.0, signifying that
  // in each bin, it is about 1.0x above a random distribution.
  // The user will not see the normalized by random values in the StatsGen Widget table,
  // but they will be stored normalized by random in the HDF5 file

  QVector<float> qRdfData = m_RDFTableModel->getData(SGRDFTableModel::Frequency);
  std::vector<float> randomFreq =
      RadialDistributionFunction::GenerateRandomDistribution(ui->minDistLE->text().toFloat(&ok), ui->maxDistLE->text().toFloat(&ok), ui->numBinsLE->text().toInt(&ok), boxDims, boxRes);

  for(int i = 0; i < qRdfDataFinal.size(); i++)
  {
    if(i + 1 < qRdfData.size() && i + 1 < randomFreq.size())
    {
      qRdfDataFinal[i] = qRdfData[i + 1] / randomFreq[i + 1];
    }
  }

  rdf->setFrequencies(qRdfDataFinal.toStdVector());

  return rdf;
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
QString StatsGenRDFWidget::getTabTitle()
{
  return QString("Radial Distribution Function");
}
