/* ============================================================================
 * Copyright (c) 2011, Michael A. Jackson (BlueQuartz Software)
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * Redistributions of source code must retain the above copyright notice, this 
 * list of conditions and the following disclaimer.
 * 
 * Redistributions in binary form must reproduce the above copyright notice, this 
 * list of conditions and the following disclaimer in the documentation and/or 
 * other materials provided with the distribution.
 * 
 * Neither the name of Michael A. Jackson nor the names of its contributors may 
 * be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* ***************************************************************************
 * THIS FILE WAS AUTOMATICALLY GENERATED FROM THE FILE LOCATED AT
 * @FilterWidgets_SOURCE_DIR@/CodeGen.cpp.in
 *************************************************************************** */

#include <stdio.h>

#include <string>
#include <map>
#include <vector>
#include <iostream>
#include <fstream>
#include <sstream>

#include "MXA/Utilities/MXADir.h"

#include "DREAM3DLib/Common/AbstractFilter.h"
#include "DREAM3DLib/Common/FilterOption.h"
#include "DREAM3DLib/DREAM3DFilters.h"

static std::string OUTPUT_DIR("@FilterWidgets_BINARY_DIR@");
static std::string FILTER_WIDGETS_DIR("@FilterWidgets_SOURCE_DIR@");
typedef std::map<std::string, std::set<std::string> >  FilterMapType;
typedef std::set<std::string>  StringSetType;

template<typename T>
void createHeaderFile( const std::string &group, const std::string &filter)
{
  typename T::Pointer t = T::New();
  std::vector<FilterOption::Pointer> options = t->getFilterOptions();
 

  std::stringstream ss;
  ss << FILTER_WIDGETS_DIR << "/" << group << "Widgets/Q" << filter << "Widget.h";
  std::string completePath = MXADir::toNativeSeparators(ss.str());
  if (MXADir::exists(completePath) == true)
  {
    std::cout << filter << ": Header already exists NOT creating a generic one." << std::endl;
    return;
  }

  ss.str("");
  ss << OUTPUT_DIR << "/" << group << "Widgets/Q" << filter << "Widget.h";
  
  completePath = MXADir::toNativeSeparators(ss.str());
  std::cout << "Creating Header File: " <<completePath << std::endl;
  
  FILE* f = fopen(completePath.c_str(), "wb");
  
  fprintf(f, "#ifndef _Q%s_H_\n", filter.c_str());
  fprintf(f, "#define _Q%s_H_\n\n", filter.c_str());

  fprintf(f, "#include <QtCore/QObject>\n");
  fprintf(f, "#include <QtCore/QSettings>\n\n");

  fprintf(f, "#include \"FilterWidgets/QFilterWidget.h\"\n");
  fprintf(f, "#include \"DREAM3DLib/%s/%s.h\"\n", group.c_str(), filter.c_str());

  fprintf(f, " class Q%sWidget : public QFilterWidget  {\n", filter.c_str());
  fprintf(f, "   Q_OBJECT;\n");
  fprintf(f, " public:\n");
  fprintf(f, "   Q%sWidget(QWidget* parent = NULL);\n", filter.c_str());
  fprintf(f, "    virtual ~Q%sWidget();\n", filter.c_str());
  fprintf(f, "    virtual AbstractFilter::Pointer getFilter();\n");
  fprintf(f, "    void writeOptions(QSettings &prefs);\n");
  fprintf(f, "    void readOptions(QSettings &prefs);\n\n");
  

  
 // Loop on all the filter options
  for(size_t i = 0; i < options.size(); ++i)
  {
    FilterOption::Pointer opt = options[i];
    std::string prop = opt->getPropertyName();
    std::string typ = opt->getValueType();
    
    if (opt->getCastableValueType().empty() == false)
    {
      std::string cType = opt->getCastableValueType();
      fprintf(f, "    Q_PROPERTY(%s %s READ get%s WRITE set%s)\n", cType.c_str(), prop.c_str(), prop.c_str(), prop.c_str());
      fprintf(f, " public slots:\n");
      fprintf(f, "    void set%s(%s v);\n", prop.c_str(), cType.c_str());
      fprintf(f, " public:\n");
      fprintf(f, "    %s  get%s();\n", cType.c_str(), prop.c_str());
    }
    else if (opt->getValueType().compare("string") == 0)
    {
      std::string cType = "QString";
      fprintf(f, "    Q_PROPERTY(%s %s READ get%s WRITE set%s)\n", cType.c_str(), prop.c_str(), prop.c_str(), prop.c_str());
      fprintf(f, " public slots:\n");
      fprintf(f, "    void set%s(const %s &v);\n", prop.c_str(), cType.c_str());
      fprintf(f, " public:\n");
      fprintf(f, "    %s  get%s();\n", cType.c_str(), prop.c_str());
    }
    else 
    {
      fprintf(f, "    Q_PROPERTY(%s %s READ get%s WRITE set%s)\n", typ.c_str(), prop.c_str(), prop.c_str(), prop.c_str());
      fprintf(f, "    FILTER_PROPERTY_WRAPPER(%s, %s, m_Filter);\n", typ.c_str(), prop.c_str());  
    }
  }

  fprintf(f, "  private:\n");
  fprintf(f, "    %s::Pointer m_Filter;\n\n", filter.c_str());
  fprintf(f, "    Q%sWidget(const Q%sWidget&);\n", filter.c_str(), filter.c_str());
  fprintf(f, "    void operator=(const Q%sWidget&);\n", filter.c_str());
  fprintf(f, "};\n");
  fprintf(f, "#endif /* Q%s_H_ */\n", filter.c_str());
  
  fclose(f);
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
template<typename T>
void createSourceFile( const std::string &group, const std::string &filter)
{
  typename T::Pointer t = T::New();
   std::vector<FilterOption::Pointer> options = t->getFilterOptions();
  

   std::stringstream ss;
   ss << FILTER_WIDGETS_DIR << "/" << group << "Widgets/Q" << filter << "Widget.h";
   std::string completePath = MXADir::toNativeSeparators(ss.str());
   if (MXADir::exists(completePath) == true)
   {
     std::cout << filter << ": Header already exists NOT creating a generic one." << std::endl;
     return;
   }

   ss.str("");
   ss << OUTPUT_DIR << "/" << group << "Widgets/Q" << filter << "Widget.cpp";
   
   completePath = MXADir::toNativeSeparators(ss.str());
   
   ss.str("");
   ss << "Q" << filter << "Widget.h";

   std::string headerFile = ss.str();
   std::cout << "Creating Header File: " <<completePath << std::endl;
   
   FILE* f = fopen(completePath.c_str(), "wb");
   

   fprintf(f, "#include \"%s\"\n\n\n", headerFile.c_str());
   
   

   fprintf(f, "Q%sWidget::Q%sWidget(QWidget* parent):  QFilterWidget(parent)\n", filter.c_str(), filter.c_str());
   fprintf(f, "{\n");
   fprintf(f, "     m_Filter = %s::New();\n", filter.c_str());
   fprintf(f, "     setupGui();\n");
   fprintf(f, "     setTitle(QString::fromStdString(m_Filter->getHumanLabel()));\n");
   fprintf(f, "}\n\n");
   fprintf(f, "Q%sWidget::~Q%sWidget(){}\n\n", filter.c_str(), filter.c_str());
   fprintf(f, "AbstractFilter::Pointer Q%sWidget::getFilter() { return m_Filter;}\n\n", filter.c_str());

  // Loop on all the filter options
   for(size_t i = 0; i < options.size(); ++i)
   {
     FilterOption::Pointer opt = options[i];
     std::string prop = opt->getPropertyName();
     std::string typ = opt->getValueType();
     
     if (opt->getCastableValueType().empty() == false)
     {
       std::string cType = opt->getCastableValueType();
       fprintf(f, "void Q%sWidget::set%s(%s v) { \n  m_Filter->set%s(static_cast<%s>(v) ); \n}\n", filter.c_str(), prop.c_str(), cType.c_str(), prop.c_str(), typ.c_str());
       fprintf(f, "%s  Q%sWidget::get%s() { \n  return static_cast<%s>(m_Filter->get%s()); \n}\n",  cType.c_str(), filter.c_str(), prop.c_str(), typ.c_str(), prop.c_str());
     }
     else if (opt->getValueType().compare("string") == 0)
     {
       std::string cType = "QString";
//       fprintf(f, "Q_PROPERTY(%s %s READ get%s WRITE set%s)\n", cType.c_str(), prop.c_str(), prop.c_str(), prop.c_str());
       fprintf(f, "void Q%sWidget::set%s(const %s &v) { \n  m_Filter->set%s(v.toStdString() ); \n}\n", filter.c_str(), prop.c_str(), cType.c_str(), prop.c_str());
       fprintf(f, "%s  Q%sWidget::get%s() { \n  return QString::fromStdString(m_Filter->get%s()); \n}\n", cType.c_str(), filter.c_str(), prop.c_str(), prop.c_str());
     }
     else 
     {
   //    fprintf(f, "Q_PROPERTY(%s %s READ get%s WRITE set%s)\n", typ.c_str(), prop.c_str(), prop.c_str(), prop.c_str());
  //     fprintf(f, "FILTER_PROPERTY_WRAPPER(%s, %s, m_Filter);\n", typ.c_str(), prop.c_str());  
     }
   }
  
  fprintf(f, "\nvoid Q%sWidget::writeOptions(QSettings &prefs)\n{\n", filter.c_str());
  fprintf(f, "  prefs.setValue(\"Filter_Name\", \"%s\" );\n", filter.c_str());
  for(size_t i = 0; i < options.size(); ++i)
  {
    FilterOption::Pointer opt = options[i];
    std::string prop = opt->getPropertyName();
    std::string typ = opt->getValueType();
    
    fprintf(f, "  prefs.setValue(\"%s\", get%s() );\n", prop.c_str(), prop.c_str());
  }
  fprintf(f, "}\n");
   
  fprintf(f, "\nvoid Q%sWidget::readOptions(QSettings &prefs)\n{\n", filter.c_str());
 // fprintf(f, "  std::cout << \"Reading Prefs for Filter  %s \" << std::endl;\n", filter.c_str());

  for(size_t i = 0; i < options.size(); ++i)
  {
    FilterOption::Pointer opt = options[i];
    std::string prop = opt->getPropertyName();
    std::string typ = opt->getValueType();
    std::string hl = opt->getHumanLabel();
    fprintf(f, "  {\n   QVariant p_%s = prefs.value(\"%s\");\n", prop.c_str(), prop.c_str());

    if (opt->getWidgetType() == FilterOption::IntWidget)
    {
      fprintf(f, "   QLineEdit* le = findChild<QLineEdit*>(\"%s\");\n", prop.c_str());
      fprintf(f, "   if (le) { le->setText(p_%s.toString()); }\n", prop.c_str());
    }
    else if (opt->getWidgetType() == FilterOption::DoubleWidget)
    {
      fprintf(f, "   QLineEdit* le = findChild<QLineEdit*>(\"%s\");\n", prop.c_str());
      fprintf(f, "   if (le) { le->setText(p_%s.toString());}\n", prop.c_str());
    }
    else if (opt->getWidgetType() == FilterOption::InputFileWidget)
    {
      fprintf(f, "   QFSDropLineEdit* lb = qFindChild<QFSDropLineEdit*>(this, \"%s\");\n", hl.c_str());
      fprintf(f, "   if (lb) { lb->setText(p_%s.toString()); }\n", prop.c_str());
      fprintf(f, "   bool ok = false;\n   ok = setProperty(\"%s\", p_%s.toString());\n", prop.c_str(), prop.c_str() );
    }
    else if (opt->getWidgetType() == FilterOption::OutputFileWidget)
    {
      fprintf(f, "   QLineEdit* lb = qFindChild<QLineEdit*>(this, \"%s\");\n", hl.c_str());
      fprintf(f, "   if (lb) { lb->setText(p_%s.toString()); }\n", prop.c_str());
      fprintf(f, "   bool ok = false;\n   ok = setProperty(\"%s\", p_%s.toString());\n", prop.c_str(), prop.c_str() );
    }
    else if (opt->getWidgetType() == FilterOption::BooleanWidget)
    {
      fprintf(f, "   QCheckBox* le = findChild<QCheckBox*>(\"%s\");\n", prop.c_str());
      fprintf(f, "   if (le) { le->setChecked(p_%s.toBool()); }\n", prop.c_str());
    }
    else if (opt->getWidgetType() == FilterOption::IntConstrainedWidget)
    {
      fprintf(f, "assert(false);\n");
    }
    else if (opt->getWidgetType() == FilterOption::DoubleContrainedWidget)
    {
      fprintf(f, "assert(false);\n");      
    }
    else if (opt->getWidgetType() == FilterOption::ChoiceWidget)
    {
      fprintf(f, "   QComboBox* cb = findChild<QComboBox*>(\"%s\");\n", prop.c_str());
      fprintf(f, "   if (cb) {\n");
      fprintf(f, "     bool ok = false;\n");
      fprintf(f, "     if (p_%s.toInt(&ok) < cb->count()) {\n", prop.c_str());
      fprintf(f, "       cb->setCurrentIndex(p_%s.toInt());\n", prop.c_str() );
      fprintf(f, "     }\n");
      fprintf(f, "   }\n");
    }
    else
    {
      fprintf(f, " #error: Class %s  Property %s  NOTHING WAS GENERATED TO READ/WRITE PROPERTY\n", hl.c_str(), prop.c_str());
    }
    fprintf(f, "  }\n");  
  }
  fprintf(f, "\n}\n");
  
  fclose(f);
}

void setFilters() {
@CODE_GEN_FILTER_FUNCTION@
}


int main(int argc, char **argv)
{

  
  setFilters();

  return 0;
}