/* ============================================================================
 * Copyright (c) 2011, Michael A. Jackson (BlueQuartz Software)
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * Redistributions of source code must retain the above copyright notice, this 
 * list of conditions and the following disclaimer.
 * 
 * Redistributions in binary form must reproduce the above copyright notice, this 
 * list of conditions and the following disclaimer in the documentation and/or 
 * other materials provided with the distribution.
 * 
 * Neither the name of Michael A. Jackson nor the names of its contributors may 
 * be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* ***************************************************************************
 * THIS FILE WAS AUTOMATICALLY GENERATED FROM THE FILE LOCATED AT
 * @FilterWidgets_SOURCE_DIR@/CodeGen.cpp.in
 *************************************************************************** */

#include <stdio.h>

#include <string>
#include <map>
#include <vector>
#include <iostream>
#include <fstream>
#include <sstream>

#include "MXA/Utilities/MXADir.h"

#include "DREAM3DLib/Common/AbstractFilter.h"
#include "DREAM3DLib/Common/FilterOption.h"
#include "FilterWidgets/DREAM3DFilterHeaders.h"

static std::string OUTPUT_DIR("@FilterWidgets_BINARY_DIR@");
static std::string FILTER_WIDGETS_DIR("@FilterWidgets_SOURCE_DIR@");
typedef std::map<std::string, std::set<std::string> >  FilterMapType;
typedef std::set<std::string>  StringSetType;

template<typename T>
void createFile( const std::string &group, const std::string &filter)
{
  typename T::Pointer t = T::New();
  std::vector<FilterOption::Pointer> options = t->getFilterOptions();
 

  std::stringstream ss;
  ss << FILTER_WIDGETS_DIR << "/" << group << "Widgets/Q" << filter << "Widget.h";
   std::string completePath = MXADir::toNativeSeparators(ss.str());
  if (MXADir::exists(completePath) == true)
  {
    std::cout << "Header '" << completePath << "' already exists NOT creating a generic one." << std::endl;
    return;
  }

  ss.str("");
  ss << OUTPUT_DIR << "/" << group << "Widgets/Q" << filter << "Widget.h";
  
  completePath = MXADir::toNativeSeparators(ss.str());
  std::cout << "Creating Header File: " <<completePath << std::endl;
  
  FILE* f = fopen(completePath.c_str(), "wb");
  
  fprintf(f, "#ifndef Q%s_H_\n", filter.c_str());
  fprintf(f, "#define Q%s_H_\n", filter.c_str());

  fprintf(f, "#include <QtCore/QObject>\n");

  fprintf(f, "#include \"FilterWidgets/QFilterWidget.h\"\n");
  fprintf(f, "#include \"DREAM3DLib/%s/%s.h\"\n", group.c_str(), filter.c_str());

  fprintf(f, " class Q%sWidget : public QFilterWidget  {\n", filter.c_str());
  fprintf(f, "   Q_OBJECT;\n");
  fprintf(f, " public:\n");
  fprintf(f, "   Q%sWidget(QWidget* parent = NULL):  QFilterWidget(parent)\n", filter.c_str());
  fprintf(f, "   {\n");
  fprintf(f, "     m_Filter = %s::New();\n", filter.c_str());
  fprintf(f, "     setupGui();\n");
  fprintf(f, "     setTitle(QString::fromStdString(m_Filter->getHumanLabel()));\n");
  fprintf(f, "    }\n");
  fprintf(f, "    virtual ~Q%sWidget(){}\n", filter.c_str());

  fprintf(f, "    virtual AbstractFilter::Pointer getFilter() { return m_Filter;}\n");

 // Loop on all the filter options
  for(size_t i = 0; i < options.size(); ++i)
  {
    FilterOption::Pointer opt = options[i];
    std::string prop = opt->getPropertyName();
    std::string typ = opt->getValueType();
    
    if (opt->getCastableValueType().empty() == false)
    {
      std::string cType = opt->getCastableValueType();
      fprintf(f, "    Q_PROPERTY(%s %s READ get%s WRITE set%s)\n", cType.c_str(), prop.c_str(), prop.c_str(), prop.c_str());
      fprintf(f, "    void set%s(%s v) { m_Filter->set%s(static_cast<%s>(v) ); }\n", prop.c_str(), cType.c_str(), prop.c_str(), typ.c_str());
      fprintf(f, "    %s  get%s() { return static_cast<%s>(m_Filter->get%s()); }\n", cType.c_str(), prop.c_str(), typ.c_str(), prop.c_str());
    }
    else 
    {
      fprintf(f, "    Q_PROPERTY(%s %s READ get%s WRITE set%s)\n", typ.c_str(), prop.c_str(), prop.c_str(), prop.c_str());
      fprintf(f, "    FILTER_PROPERTY_WRAPPER(%s, %s, m_Filter);\n", typ.c_str(), prop.c_str());  
    }
  }
 
  fprintf(f, "  private:\n");
  fprintf(f, "    %s::Pointer m_Filter;\n\n", filter.c_str());
  fprintf(f, "    Q%sWidget(const Q%sWidget&);", filter.c_str(), filter.c_str());
  fprintf(f, "    void operator=(const Q%sWidget&);", filter.c_str());
  fprintf(f, "};\n");
  fprintf(f, "#endif /* Q%s_H_ */\n", filter.c_str());
  
  fclose(f);
}


void setFilters() {
@CODE_GEN_FILTER_FUNCTION@
}


int main(int argc, char **argv)
{

  
  setFilters();

  return 0;
}