/* ============================================================================
 * Copyright (c) 2012 Michael A. Jackson (BlueQuartz Software)
 * Copyright (c) 2012 Dr. Michael A. Groeber (US Air Force Research Laboratories)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright notice, this
 * list of conditions and the following disclaimer in the documentation and/or
 * other materials provided with the distribution.
 *
 * Neither the name of Michael A. Groeber, Michael A. Jackson, the US Air Force,
 * BlueQuartz Software nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *  This code was written under United States Air Force Contract number
 *                           FA8650-10-D-5210
 *
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#include "ArraySelectionWidget.h"

#include <QtCore/QMetaProperty>
#include <QtCore/QList>
#include <QtGui/QListWidgetItem>


// This is auto generated by the "moc" program
#include "DREAM3DWidgetsLib/FilterParameterWidgets/moc_ArraySelectionWidget.cxx"

#define DATA_CONTAINER_LEVEL 0
#define ATTRIBUTE_MATRIX_LEVEL 1
#define ATTRIBUTE_ARRAY_LEVEL 2
// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
ArraySelectionWidget::ArraySelectionWidget(FilterParameter* parameter, AbstractFilter* filter, QWidget* parent) :
  QWidget(parent),
  m_Filter(filter),
  m_FilterParameter(parameter)
{
  setupUi(this);
  setupGui();
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
ArraySelectionWidget::~ArraySelectionWidget()
{}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
void ArraySelectionWidget::setupGui()
{
  qRegisterMetaType<DataContainerArrayProxy>("DataContainerArrayProxy");
  // The filter should emit this signal when a filter changes.
  //  connect(m_Filter, SIGNAL(parametersChanged()),
  //          this, SLOT(initializeHeirarchy() ) );

  connect(m_Filter, SIGNAL(preflightAboutToExecute()),
          this, SLOT(beforePreflight() ) );

  connect(m_Filter, SIGNAL(preflightExecuted()),
          this, SLOT(afterPreflight()) );

  if (m_FilterParameter != NULL)
  {
    ArraySelectionWidgetLabel->setText(m_FilterParameter->getHumanLabel() );
    beforePreflight(); // Run this to get the initial DataContainerArray from the filter instance so we can populate
  }
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
void ArraySelectionWidget::on_dataContainerList_currentItemChanged(QListWidgetItem* dcWidgetItem, QListWidgetItem* previous)
{
  if(NULL == dcWidgetItem)
  {
    return;
  }
  //std::cout << "void ArraySelectionWidget::on_dataContainerList_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous)" << std::endl;

  // Clear the AttributeMatrix List
  attributeMatrixList->clear();

  // Loop over the data containers until we find the proper data container
  QList<DataContainerProxy> containers = m_DcaProxy.list;
  QListIterator<DataContainerProxy> containerIter(containers);
  while(containerIter.hasNext())
  {
    DataContainerProxy dc = containerIter.next();
    if(dc.name.compare(dcWidgetItem->data(Qt::UserRole).toString() ) == 0 )
    {
      // We found the proper Data Container, now populate the AttributeMatrix List
      QMap<QString, AttributeMatrixProxy> attrMats = dc.attributeMatricies;
      QMapIterator<QString, AttributeMatrixProxy> attrMatsIter(attrMats);
      while(attrMatsIter.hasNext() )
      {
        attrMatsIter.next();
        QString amName = attrMatsIter.key();
        QListWidgetItem* listItem = new QListWidgetItem(amName, attributeMatrixList);
        listItem->setData( Qt::UserRole, amName);
      }
    }
  }

}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
void ArraySelectionWidget::on_dataContainerList_itemClicked(QListWidgetItem* dcWidgetItem)
{
  if(true) return;
  if(NULL == dcWidgetItem)
  {
    return;
  }

  // Nothing is selected
  if(dataContainerList->currentRow() == -1)
  {
    dcWidgetItem->setCheckState(Qt::Checked);
  }

  if(dcWidgetItem->checkState() == Qt::Unchecked )
  {
    attributeMatrixList->clear();
    dataContainerList->setCurrentRow(-1);
  }
  if(dcWidgetItem->checkState() == Qt::Checked )
  {
    on_dataContainerList_currentItemChanged(dcWidgetItem, NULL);
  }
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
void ArraySelectionWidget::on_attributeMatrixList_currentItemChanged(QListWidgetItem* amWidget, QListWidgetItem* previous)
{
  if(NULL == amWidget)
  {
    return;
  }
  //std::cout << "on_attributeMatrixList_currentItemChanged" << std::endl;

  // Get the selected Data Container Name from the DataContainerList Widget
  QListWidgetItem* dcWidgetItem = dataContainerList->currentItem();



  // Loop over the data containers until we find the proper data container
  QList<DataContainerProxy> containers = m_DcaProxy.list;
  QListIterator<DataContainerProxy> containerIter(containers);
  while(containerIter.hasNext())
  {
    DataContainerProxy dc = containerIter.next();
    if(dc.name.compare(dcWidgetItem->data(Qt::UserRole).toString() ) == 0 )
    {
      // We found the proper Data Container, now populate the AttributeMatrix List
      QMap<QString, AttributeMatrixProxy> attrMats = dc.attributeMatricies;
      QMapIterator<QString, AttributeMatrixProxy> attrMatsIter(attrMats);
      while(attrMatsIter.hasNext() )
      {
        attrMatsIter.next();
        QString amName = attrMatsIter.key();
        if(amName.compare(amWidget->data(Qt::UserRole).toString() ) == 0 )
        {
          // Clear the list of arrays from the QListWidget
          attributeArrayList->clear();
          // We found the selected AttributeMatrix, so loop over this attribute matrix arrays and populate the list widget
          AttributeMatrixProxy amProxy = attrMatsIter.value();
          QMap<QString, DataArrayProxy> dataArrays = amProxy.dataArrays;
          QMapIterator<QString, DataArrayProxy> dataArraysIter(dataArrays);
          while(dataArraysIter.hasNext() )
          {
            dataArraysIter.next();
            DataArrayProxy daProxy = dataArraysIter.value();
            QString daName = dataArraysIter.key();
            QListWidgetItem* listItem = new QListWidgetItem(daName, attributeArrayList);
            listItem->setData( Qt::UserRole, daName);
          }
        }
      }
    }
  }
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
void ArraySelectionWidget::on_attributeArrayList_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous)
{
  if(NULL == current)
  {
    return;
  }
  qDebug() << m_Filter->getNameOfClass() << "::" << m_FilterParameter->getHumanLabel() << "::" << "on_attributeArrayList_currentItemChanged" ;

  // Set this value into the m_FilterInstance as the specified Filter Property, Which will cause a preflight to occur
  // because the parameters have changed. which will reset the lists, which causes a preflight..
  this->blockSignals(true);
  m_Filter->blockSignals(true); // Make sure the filter does not fire off the parametersChanged() signal too soon

  // Generate the DataContainerArrayProxy object to pass over to the filter, letting the filter know what the
  // user has selected
  DataContainerArrayProxy dcaProxy = generateDCAProxy();


  QVariant var;
  var.setValue(m_DcaProxy);
  bool ok = false;

  ok = m_Filter->setProperty(PROPERTY_NAME_AS_CHAR, var);
  if(false == ok)
  {
    QString ss = QObject::tr("Error occurred setting Filter Parameter '%1'").arg(m_FilterParameter->getPropertyName() );
    emit errorSettingFilterParameter(ss);
    qDebug() << ss;
  }


#if 0
  // Set the DataContainerName
  QVariant dcName = dataContainerList->currentItem()->data(Qt::UserRole);
  ok = m_Filter->setProperty("DataContainerName", dcName);
  if(false == ok)
  {
    QString ss = QObject::tr("Error occurred setting Filter Parameter 'DataContainerName'");
    emit errorSettingFilterParameter(ss);
  }

  QListWidgetItem* amSelectedItem = attributeMatrixList->currentItem();
  if(NULL == amSelectedItem) { return; }
  QVariant amName = amSelectedItem->data(Qt::UserRole);
  ok = m_Filter->setProperty("AttributeMatrixName", amName);
  if(false == ok)
  {
    QString ss = QObject::tr("Error occurred setting Filter Parameter 'AttributeMatrixName'");
    emit errorSettingFilterParameter(ss);
  }

  m_Filter->blockSignals(false); // Let the filter instance now fire the parameters Changed signal when we set this last parameter
  QVariant daName = attributeArrayList->currentItem()->data(Qt::UserRole);
  ok = m_Filter->setProperty(PROPERTY_NAME_AS_CHAR, daName);
  if(false == ok)
  {
    QString ss = QObject::tr("Error occurred setting Filter Parameter %1").arg(m_FilterParameter->getPropertyName());
    emit errorSettingFilterParameter(ss);
  }
#endif
  this->blockSignals(false);
  m_Filter->blockSignals(false); // Make sure the filter does not fire off the parametersChanged() signal too soon

}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
void ArraySelectionWidget::initializeHeirarchy()
{
  //  std::cout << "Filter Parameter Widget should update" << std::endl;
  dataContainerList->clear();
  attributeMatrixList->clear();
  attributeArrayList->clear();

  if (NULL == m_Filter) { return; }

  QList<DataContainerProxy> dcList = m_DcaProxy.list;
  QListIterator<DataContainerProxy> iter(dcList);
  while(iter.hasNext() )
  {
    DataContainerProxy dc = iter.next();
    QListWidgetItem* listItem = new QListWidgetItem(dc.name, dataContainerList);
    listItem->setData( Qt::UserRole, dc.name);
    // listItem->setCheckState(Qt::Checked);
  }
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
void ArraySelectionWidget::beforePreflight()
{
  if (NULL == m_Filter) { return; }
  //  std::cout << "Before Preflight" << std::endl;

  // Now get the DataContainerArray from the Filter instance
  // We are going to use this to get all the current DataContainers
  DataContainerArray::Pointer dca = m_Filter->getDataContainerArray();
  if(NULL == dca.get()) { return; }
  m_DcaProxy = DataContainerArrayProxy(dca.get());

  initializeHeirarchy(); // Now actually populate the QListWidgets based on the Proxy values

  // now get the selection from the filter
  DataContainerArrayProxy dcaProxy = m_Filter->property(PROPERTY_NAME_AS_CHAR).value<DataContainerArrayProxy>();
  QString dcName;
  QString amName;
  QString daName;
  QStringList names = dcaProxy.flattenHeirarchy();
  // Save what was selected from the filter
  if( names.size() > 0)
  {
    QString selectedPath = names.at(0);
    QStringList tokens = selectedPath.split(DREAM3D::PathSep);

    if(tokens.size() > 0) dcName = tokens.at(0);
    if(tokens.size() > 1) amName = tokens.at(1);
    if(tokens.size() > 2) daName = tokens.at(2);
  }
  // Set the correct DataContainer
  int count = dataContainerList->count();
  dataContainerList->setCurrentRow(-1);
  for(int i = 0; i < count; i++)
  {
    if (dataContainerList->item(i)->data(Qt::UserRole).toString().compare(dcName) == 0 )
    {
      dataContainerList->setCurrentRow(i); // This will fire the currentItemChanged(...) signal
      break;
    }
  }

  // Set the correct AttributeMatrix
  count = attributeMatrixList->count();
  attributeMatrixList->setCurrentRow(-1);
  for(int i = 0; i < count; i++)
  {
    if (attributeMatrixList->item(i)->data(Qt::UserRole).toString().compare(amName) == 0 )
    {
      attributeMatrixList->setCurrentRow(i); // This will fire the currentItemChanged(...) signal
      break;
    }
  }

  attributeArrayList->blockSignals(true);
  // Set the correct Data Array (if Possible). It may have changed since we started
  count = attributeArrayList->count();
  attributeArrayList->setCurrentRow(-1);
  for(int i = 0; i < count; i++)
  {
    if (attributeArrayList->item(i)->data(Qt::UserRole).toString().compare(daName) == 0 )
    {
      attributeArrayList->setCurrentRow(i); // This will fire the currentItemChanged(...) signal
      break;
    }
  }
  attributeArrayList->blockSignals(false);


}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
void ArraySelectionWidget::afterPreflight()
{
  // std::cout << "After Preflight" << std::endl;
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
DataContainerArrayProxy ArraySelectionWidget::generateDCAProxy()
{
  // This will only work for a single selection
  DataContainerArrayProxy dcaProxy(true);
  QString dcaName = dataContainerList->currentItem()->text();
  DataContainerProxy dcProxy(dcaName, true);

  QString amName = attributeMatrixList->currentItem()->text();
  AttributeMatrixProxy amProxy(amName, true);

  QString daName = attributeArrayList->currentItem()->text();
  DataArrayProxy daProxy(dcaName + "|" + amName, daName, true);
  amProxy.dataArrays.insert(daName, daProxy);
  dcProxy.attributeMatricies.insert(amName, amProxy);
  dcaProxy.list.push_back(dcProxy);

  return dcaProxy;
}
