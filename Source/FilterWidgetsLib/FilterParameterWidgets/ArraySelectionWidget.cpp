/* ============================================================================
 * Copyright (c) 2012 Michael A. Jackson (BlueQuartz Software)
 * Copyright (c) 2012 Dr. Michael A. Groeber (US Air Force Research Laboratories)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright notice, this
 * list of conditions and the following disclaimer in the documentation and/or
 * other materials provided with the distribution.
 *
 * Neither the name of Michael A. Groeber, Michael A. Jackson, the US Air Force,
 * BlueQuartz Software nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *  This code was written under United States Air Force Contract number
 *                           FA8650-10-D-5210
 *
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#include "ArraySelectionWidget.h"

#include <QtCore/QMetaProperty>
#include <QtCore/QList>
#include <QtGui/QListWidgetItem>


// This is auto generated by the "moc" program
#include "FilterWidgetsLib/FilterParameterWidgets/moc_ArraySelectionWidget.cxx"

#define DATA_CONTAINER_LEVEL 0
#define ATTRIBUTE_MATRIX_LEVEL 1
#define ATTRIBUTE_ARRAY_LEVEL 2
// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
ArraySelectionWidget::ArraySelectionWidget(FilterParameter* parameter, AbstractFilter* filter, QWidget* parent) :
  QWidget(parent),
  m_Filter(filter),
  m_FilterParameter(parameter)
{
  setupUi(this);
  setupGui();
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
ArraySelectionWidget::~ArraySelectionWidget()
{}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
void ArraySelectionWidget::setupGui()
{

  // The filter should emit this signal when a filter changes.
  //  connect(m_Filter, SIGNAL(parametersChanged()),
  //          this, SLOT(initializeHeirarchy() ) );

  connect(m_Filter, SIGNAL(preflightAboutToExecute()),
          this, SLOT(beforePreflight() ) );

  connect(m_Filter, SIGNAL(preflightExecuted()),
          this, SLOT(afterPreflight()) );

  if (m_FilterParameter != NULL)
  {
    ArraySelectionWidgetLabel->setText(m_FilterParameter->getHumanLabel() );
    beforePreflight(); // Run this to get the initial DataContainerArray from the filter instance so we can populate
  }
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
void ArraySelectionWidget::on_dataContainerList_currentItemChanged(QListWidgetItem* dcWidgetItem, QListWidgetItem* previous)
{
  if(NULL == dcWidgetItem)
  {
    return;
  }
  std::cout << "void ArraySelectionWidget::on_dataContainerList_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous)" << std::endl;

  // Clear the AttributeMatrix List
  attributeMatrixList->clear();

  // Loop over the data containers until we find the proper data container
  QList<DataContainerProxy> containers = m_DcaProxy.list;
  QListIterator<DataContainerProxy> containerIter(containers);
  while(containerIter.hasNext())
  {
    DataContainerProxy dc = containerIter.next();
    if(dc.name.compare(dcWidgetItem->data(Qt::UserRole).toString() ) == 0 )
    {
      // We found the proper Data Container, now populate the AttributeMatrix List
      QMap<QString, AttributeMatrixProxy> attrMats = dc.attributeMatricies;
      QMapIterator<QString, AttributeMatrixProxy> attrMatsIter(attrMats);
      while(attrMatsIter.hasNext() )
      {
        attrMatsIter.next();
        QString amName = attrMatsIter.key();
        QListWidgetItem* listItem = new QListWidgetItem(amName, attributeMatrixList);
        listItem->setData( Qt::UserRole, amName);
      }
    }
  }

}


// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
void ArraySelectionWidget::on_attributeMatrixList_currentItemChanged(QListWidgetItem* amWidget, QListWidgetItem* previous)
{
  if(NULL == amWidget)
  {
    return;
  }
  std::cout << "on_attributeMatrixList_currentItemChanged" << std::endl;

  // Get the selected Data Container Name from the DataContainerList Widget
  QListWidgetItem* dcWidgetItem = dataContainerList->currentItem();



  // Loop over the data containers until we find the proper data container
  QList<DataContainerProxy> containers = m_DcaProxy.list;
  QListIterator<DataContainerProxy> containerIter(containers);
  while(containerIter.hasNext())
  {
    DataContainerProxy dc = containerIter.next();
    if(dc.name.compare(dcWidgetItem->data(Qt::UserRole).toString() ) == 0 )
    {
      // We found the proper Data Container, now populate the AttributeMatrix List
      QMap<QString, AttributeMatrixProxy> attrMats = dc.attributeMatricies;
      QMapIterator<QString, AttributeMatrixProxy> attrMatsIter(attrMats);
      while(attrMatsIter.hasNext() )
      {
        attrMatsIter.next();
        QString amName = attrMatsIter.key();
        if(amName.compare(amWidget->data(Qt::UserRole).toString() ) == 0 )
        {
          // Clear the list of arrays from the QListWidget
          attributeArrayList->clear();
          // We found the selected AttributeMatrix, so loop over this attribute matrix arrays and populate the list widget
          AttributeMatrixProxy amProxy = attrMatsIter.value();
          QMap<QString, DataArrayProxy> dataArrays = amProxy.dataArrays;
          QMapIterator<QString, DataArrayProxy> dataArraysIter(dataArrays);
          while(dataArraysIter.hasNext() )
          {
            dataArraysIter.next();
            DataArrayProxy daProxy = dataArraysIter.value();
            QString daName = dataArraysIter.key();
            QListWidgetItem* listItem = new QListWidgetItem(daName, attributeArrayList);
            listItem->setData( Qt::UserRole, daName);
          }
        }
      }
    }
  }
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
void ArraySelectionWidget::on_attributeArrayList_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous)
{
  if(NULL == current)
  {
    return;
  }
  std::cout << "on_attributeArrayList_currentItemChanged" << std::endl;

  // Set this value into the m_FilterInstance as the specified Filter Property, Which will cause a preflight to occur
  // because the parameters have changed. which will reset the lists, which causes a preflight..
  this->blockSignals(true);
  m_Filter->blockSignals(true); // Make sure the filter does not fire off the parametersChanged() signal too soon
  bool ok = false;
  // Set the DataContainerName
  QVariant dcName = dataContainerList->currentItem()->data(Qt::UserRole);
  ok = m_Filter->setProperty("DataContainerName", dcName);
  if(false == ok)
  {
    QString ss = QObject::tr("Error occurred setting Filter Parameter 'DataContainerName'");
    emit errorSettingFilterParameter(ss);
  }

  QListWidgetItem* amSelectedItem = attributeMatrixList->currentItem();
  if(NULL == amSelectedItem) { return; }
  QVariant amName = amSelectedItem->data(Qt::UserRole);
  ok = m_Filter->setProperty("AttributeMatrixName", amName);
  if(false == ok)
  {
    QString ss = QObject::tr("Error occurred setting Filter Parameter 'AttributeMatrixName'");
    emit errorSettingFilterParameter(ss);
  }

  m_Filter->blockSignals(false); // Let the filter instance now fire the parameters Changed signal when we set this last parameter
  QVariant daName = attributeArrayList->currentItem()->data(Qt::UserRole);
  ok = m_Filter->setProperty(PROPERTY_NAME_AS_CHAR, daName);
  if(false == ok)
  {
    QString ss = QObject::tr("Error occurred setting Filter Parameter %1").arg(m_FilterParameter->getPropertyName());
    emit errorSettingFilterParameter(ss);
  }

  this->blockSignals(false);
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
void ArraySelectionWidget::initializeHeirarchy()
{
  std::cout << "Filter Parameter Widget should update" << std::endl;
  dataContainerList->clear();
  attributeMatrixList->clear();
  attributeArrayList->clear();

  if (NULL == m_Filter) { return; }

  QList<DataContainerProxy> dcList = m_DcaProxy.list;
  QListIterator<DataContainerProxy> iter(dcList);
  while(iter.hasNext() )
  {
    DataContainerProxy dc = iter.next();
    QListWidgetItem* listItem = new QListWidgetItem(dc.name, dataContainerList);
    listItem->setData( Qt::UserRole, dc.name);
  }
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
void ArraySelectionWidget::beforePreflight()
{
  if (NULL == m_Filter) { return; }
  std::cout << "Before Preflight" << std::endl;
  // Save what was selected from the filter
  QString dcName = m_Filter->property("DataContainerName").toString();
  QString amName = m_Filter->property("AttributeMatrixName").toString();
  QString daName = m_Filter->property(PROPERTY_NAME_AS_CHAR).toString();

  // Now get the DataContainerArray from the Filter instance
  DataContainerArray::Pointer dca = m_Filter->getDataContainerArray();
  if(NULL == dca.get()) { return; }

  std::cout << "    Making a DataContainerArrayProxy copy into ArraySelectionWidget" << std::endl;
  // update our local cache of the DataContainerProxy to be that of the current DataContainerArray
  m_DcaProxy = DataContainerArrayProxy(dca.get());

  initializeHeirarchy(); // Now actually populate the QListWidgets based on the Proxy values

  // Set the correct DataContainer
  int count = dataContainerList->count();
  dataContainerList->setCurrentRow(-1);
  for(int i = 0; i < count; i++)
  {
    if (dataContainerList->item(i)->data(Qt::UserRole).toString().compare(dcName) == 0 )
    {
      dataContainerList->setCurrentRow(i); // This will fire the currentItemChanged(...) signal
      break;
    }
  }

  // Set the correct AttributeMatrix
  count = attributeMatrixList->count();
  attributeMatrixList->setCurrentRow(-1);
  for(int i = 0; i < count; i++)
  {
    if (attributeMatrixList->item(i)->data(Qt::UserRole).toString().compare(amName) == 0 )
    {
      attributeMatrixList->setCurrentRow(i); // This will fire the currentItemChanged(...) signal
      break;
    }
  }

  attributeArrayList->blockSignals(true);
  // Set the correct Data Array (if Possible). It may have changed since we started
  count = attributeArrayList->count();
  attributeArrayList->setCurrentRow(-1);
  for(int i = 0; i < count; i++)
  {
    if (attributeArrayList->item(i)->data(Qt::UserRole).toString().compare(daName) == 0 )
    {
      attributeArrayList->setCurrentRow(i); // This will fire the currentItemChanged(...) signal
      break;
    }
  }
  attributeArrayList->blockSignals(false);


}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
void ArraySelectionWidget::afterPreflight()
{
  std::cout << "After Preflight" << std::endl;
}
