

#include "DREAM3DFileStructure.h"


#include <QtCore/QSettings>
#include <QtCore/QFile>
#include <QtCore/QFileInfo>

#include "H5Support/H5Support.h"
#include "H5Support/QH5Lite.h"
#include "H5Support/QH5Utilities.h"
#include "H5Support/HDF5ScopedFileSentinel.h"

#include "SIMPLib/Common/Constants.h"
#include "SIMPLib/DataContainers/DataArrayProxy.h"
#include "SIMPLib/DataContainers/AttributeMatrixProxy.h"
#include "SIMPLib/DataContainers/DataContainerProxy.h"
#include "SIMPLib/CoreFilters/DataContainerReader.h"
#include "SIMPLib/FilterParameters/QFilterParametersWriter.h"
#include "SIMPLib/FilterParameters/H5FilterParametersWriter.h"
#include "SIMPLib/FilterParameters/QFilterParametersReader.h"
#include "SIMPLib/FilterParameters/H5FilterParametersReader.h"


// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
DREAM3DFileStructure::DREAM3DFileStructure()
{

}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
DREAM3DFileStructure::~DREAM3DFileStructure()
{

}

// -----------------------------------------------------------------------------
/*
 * This function shows creating a DataContainer from the "Proxy" data container
 * structure that has been generated by walking the file. This function could be
 * transferred to the DataContainerReader as a static function perhaps or used
 * elsewhere in the code. The GUI would generate the "Proxy" structure then pass
 * that Proxy Structure to the DataContainer reader as an DREAM3D_PROPERTY. If
 * the Proxy was nullptr in the DataContainer then that would signal the DataContainerReader
 * to read EVERY thing from the file. If the Proxy was valid but essentially empty
 * then nothing is read from the file. If the Proxy has some structure saved in it
 * then the DataContainer reader would know exactly what to read.
 */
// -----------------------------------------------------------------------------
DataContainerArray::Pointer _createDataContainerArray(DataContainerArrayProxy& dcaProxy)
{
  DataContainerArray::Pointer dcArray = DataContainerArray::New();

  QList<DataContainerProxy> dcProxies = dcaProxy.dataContainers.values();
  QListIterator<DataContainerProxy> dcIter(dcProxies);
  while (dcIter.hasNext()) // DataContainerLevel
  {



    const DataContainerProxy& dcProxy =  dcIter.next();
    std::cout << "Found " << dcProxy.name.toStdString() << ": " << std::endl;
    if(dcProxy.flag == Qt::Unchecked) { continue; } // Skip to the next DataContainer if we are not reading this one.

    std::cout << "  reading " << dcProxy.name.toStdString() << ": " << std::endl;
    // Create the real DataContainer Object and push it into the DataContainerArray object
    DataContainer::Pointer dataContainer = DataContainer::New();
    dataContainer->setName(dcProxy.name);
    dcArray->addDataContainer(dataContainer);

    QMapIterator<QString, AttributeMatrixProxy> amIter(dcProxy.attributeMatricies);
    while(amIter.hasNext()) // AttributeMatrixLevel
    {
      amIter.next();
      std::cout << "  Found " << amIter.key().toStdString() << ": " << std::endl;

      const AttributeMatrixProxy& amProxy = amIter.value();
      if(amProxy.flag == Qt::Unchecked) { continue; } // Skip to the next AttributeMatrix if not reading this one

      std::cout << "    reading " << amIter.key().toStdString() << std::endl;
      QVector<size_t> tupleDims(1, 0);
      AttributeMatrix::Pointer attrMatrix = AttributeMatrix::New(tupleDims, amProxy.name, amProxy.amType);

      QMapIterator<QString, DataArrayProxy> dIter(amProxy.dataArrays);
      while(dIter.hasNext()) // DataArray Level
      {
        dIter.next();
        std::cout << "    Found " << dIter.key().toStdString() << ": " << std::endl;

        const DataArrayProxy& daProxy = dIter.value();
        if(daProxy.flag == DREAM3D::Unchecked) { continue; } // Skip to the next DataArray if not reading this one

        std::cout << "      reading " << dIter.key().toStdString() << std::endl;

        if(daProxy.objectType.compare("DataArray<int8_t>") == 0 )
        {
          // attrMatrix->createAndAddAttributeArray /* If we did this then the array is going to get allocated and that may be a LOT of RAM to use for nothing. */
          /* We can not use AttributeMatrix->addAttributeArray() because that will validate the number of Tuples matches
           * the number of tuples in the DataArray. If we set everything to Zero sizes then we loose the meta data of the
           * tuple dimensions at this point which we will need later when we finally read the arrays. */
        }
        else if(daProxy.objectType.compare("DataArray<uint8_t>") == 0 ) {}
        else if(daProxy.objectType.compare("DataArray<int16_t>") == 0 ) {}
        else if(daProxy.objectType.compare("DataArray<uint16_t>") == 0 ) {}
        else if(daProxy.objectType.compare("DataArray<int32_t>") == 0 ) {}
        else if(daProxy.objectType.compare("DataArray<uint32_t>") == 0 ) {}
        else if(daProxy.objectType.compare("DataArray<int64_t>") == 0 ) {}
        else if(daProxy.objectType.compare("DataArray<uint64_t>") == 0 ) {}
        else if(daProxy.objectType.compare("DataArray<float>") == 0 ) {}
        else if(daProxy.objectType.compare("DataArray<double>") == 0 ) {}


      }

      dataContainer->addAttributeMatrix(amProxy.name, attrMatrix);
    }
  }

  return dcArray;
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
DataContainerArray::Pointer DREAM3DFileStructure::ReadFileStructure(const QString& filePath)
{
  // Create an instance of the DataContainerReader
  DataContainerReader::Pointer reader = DataContainerReader::New();
  reader->setInputFile(filePath);

  // Read the structure of the Data container from the file marking all elements as readable.
  DataContainerArrayProxy proxy = reader->readDataContainerArrayStructure(filePath);
//  proxy.list[0].read = false;
//  proxy.list[1].read = false;
//  proxy.list[2].read = false;

  reader->setInputFileDataContainerArrayProxy(proxy);

  // Now create a QSettings based writer to write the parameters to a .ini file
  QFilterParametersWriter::Pointer qWriter = QFilterParametersWriter::New();
  QString iniFile("out.ini");
  QFileInfo fi(iniFile);
  if (fi.exists() == true)
  {
    QFile(iniFile).remove();
  }
  qWriter->openFile("out.ini", QSettings::IniFormat);
  // Write the Filter Parameters to the file
  reader->writeFilterParameters(qWriter.get(), 0);
  qWriter->closeFile();

  std::cout << "-----------------------------------------------------------------------------------------" << std::endl;
  QFilterParametersReader::Pointer qReader = QFilterParametersReader::New();
  qReader->openFile("out.ini", QSettings::IniFormat);
  reader->readFilterParameters(qReader.get(), 0);
  qReader->closeFile();

  DataContainerArrayProxy dcaProxyFromIni = reader->getInputFileDataContainerArrayProxy();


  // This would create the actual DataContainerArray instance. The above function does most of the work but will
  // fail to create the data Arrays properly. THis code is just here as an example
  DataContainerArray::Pointer dcArray = _createDataContainerArray(dcaProxyFromIni);

  return dcArray;
}



