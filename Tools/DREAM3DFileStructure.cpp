

#include "DREAM3DFileStructure.h"


#include <QtCore/QSettings>
#include <QtCore/QFile>
#include <QtCore/QFileInfo>

#include "H5Support/H5Support.h"
#include "H5Support/QH5Lite.h"
#include "H5Support/QH5Utilities.h"
#include "H5Support/HDF5ScopedFileSentinel.h"

#include "DREAM3DLib/Common/Constants.h"
#include "DREAM3DLib/DataContainers/DataArrayProxy.h"
#include "DREAM3DLib/DataContainers/AttributeMatrixProxy.h"
#include "DREAM3DLib/DataContainers/DataContainerProxy.h"
#include "DREAM3DLib/IOFilters/DataContainerReader.h"
#include "DREAM3DLib/FilterParameters/QFilterParametersWriter.h"
#include "DREAM3DLib/FilterParameters/H5FilterParametersWriter.h"



// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
DREAM3DFileStructure::DREAM3DFileStructure()
{

}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
DREAM3DFileStructure::~DREAM3DFileStructure()
{

}

// -----------------------------------------------------------------------------
/*
 * This function shows creating a DataContainer from the "Proxy" data container
 * structure that has been generated by walking the file. This function could be
 * transferred to the DataContainerReader as a static function perhaps or used
 * elsewhere in the code. The GUI would generate the "Proxy" structure then pass
 * that Proxy Structure to the DataContainer reader as an DREAM3D_PROPERTY. If
 * the Proxy was NULL in the DataContainer then that would signal the DataContainerReader
 * to read EVERY thing from the file. If the Proxy was valid but essentially empty
 * then nothing is read from the file. If the Proxy has some structure saved in it
 * then the DataContainer reader would know exactly what to read.
 */
// -----------------------------------------------------------------------------
DataContainerArray::Pointer _createDataContainerArray(DataContainerArrayProxy &dcaProxy)
{
  DataContainerArray::Pointer dcArray = DataContainerArray::New();

  QListIterator<DataContainerProxy> dcIter(dcaProxy.list);
  while (dcIter.hasNext()) // DataContainerLevel
  {



    const DataContainerProxy& dcProxy =  dcIter.next();
    std::cout << "Found " << dcProxy.name.toStdString() << ": " << std::endl;
    if(dcProxy.read == false) { continue; } // Skip to the next DataContainer if we are not reading this one.

    std::cout << "  reading " << dcProxy.name.toStdString() << ": " << std::endl;
    // Create the real DataContainer Object and push it into the DataContainerArray object
    DataContainer::Pointer dataContainer = DataContainer::New();
    dataContainer->setName(dcProxy.name);
    dcArray->pushBack(dataContainer);

    QMapIterator<QString, AttributeMatrixProxy> amIter(dcProxy.attributeMatricies);
    while(amIter.hasNext()) // AttributeMatrixLevel
    {
      amIter.next();
      std::cout << "  Found " << amIter.key().toStdString() << ": " << std::endl;

      const AttributeMatrixProxy& amProxy = amIter.value();
      if(amProxy.read == false) { continue; } // Skip to the next AttributeMatrix if not reading this one

      std::cout << "    reading " << amIter.key().toStdString() << std::endl;
      QVector<size_t> tupleDims(1,0);
      AttributeMatrix::Pointer attrMatrix = AttributeMatrix::New(tupleDims, amProxy.name, amProxy.amType);

      QMapIterator<QString, DataArrayProxy> dIter(amProxy.dataArrays);
      while(dIter.hasNext()) // DataArray Level
      {
        dIter.next();
        std::cout << "    Found " << dIter.key().toStdString() << ": " << std::endl;

        const DataArrayProxy& daProxy = dIter.value();
        if(daProxy.read == false) { continue; } // Skip to the next DataArray if not reading this one

        std::cout << "      reading " << dIter.key().toStdString() << std::endl;

        if(daProxy.objectType.compare("DataArray<int8_t>") == 0 ){
          // attrMatrix->createAndAddAttributeArray /* If we did this then the array is going to get allocated and that may be a LOT of RAM to use for nothing. */
          /* We can not use AttributeMatrix->addAttributeArray() because that will validate the number of Tuples matches
           * the number of tuples in the DataArray. If we set everything to Zero sizes then we loose the meta data of the
           * tuple dimensions at this point which we will need later when we finally read the arrays. */
        }
        else if(daProxy.objectType.compare("DataArray<uint8_t>") == 0 ){}
        else if(daProxy.objectType.compare("DataArray<int16_t>") == 0 ){}
        else if(daProxy.objectType.compare("DataArray<uint16_t>") == 0 ){}
        else if(daProxy.objectType.compare("DataArray<int32_t>") == 0 ){}
        else if(daProxy.objectType.compare("DataArray<uint32_t>") == 0 ){}
        else if(daProxy.objectType.compare("DataArray<int64_t>") == 0 ){}
        else if(daProxy.objectType.compare("DataArray<uint64_t>") == 0 ){}
        else if(daProxy.objectType.compare("DataArray<float>") == 0 ){}
        else if(daProxy.objectType.compare("DataArray<double>") == 0 ){}


      }

      dataContainer->addAttributeMatrix(amProxy.name, attrMatrix);
    }
  }

  return dcArray;
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
DataContainerArray::Pointer DREAM3DFileStructure::ReadFileStructure(const QString &filePath)
{
  // Create an instance of the DataContainerReader
  DataContainerReader::Pointer reader = DataContainerReader::New();
  reader->setInputFile(filePath);

  // Read the structure of the Data container from the file marking all elements as readable.
  DataContainerArrayProxy proxy = reader->readDataContainerArrayStructure();
//  proxy.list[0].read = false;
//  proxy.list[1].read = false;
//  proxy.list[2].read = false;

  reader->setDataContainerArrayProxy(proxy);

  // Now create a QSettings based writer to write the parameters to a .ini file
  QFilterParametersWriter::Pointer qWriter = QFilterParametersWriter::New();
  QString iniFile("/tmp/out.ini");
  QFileInfo fi(iniFile);
  if (fi.exists() == true)
  {
    QFile(iniFile).remove();
  }
  qWriter->openFile("/tmp/out.ini", QSettings::IniFormat);
  // Write the Filter Parameters to the file
  reader->writeFilterParameters(qWriter.get(), 0);



  qWriter->closeFile();

  // This would create the actual DataContainerArray instance. The above function does most of the work but will
  // fail to create the data Arrays properly. THis code is just here as an example
  DataContainerArray::Pointer dcArray = _createDataContainerArray(proxy);

  return dcArray;
}



