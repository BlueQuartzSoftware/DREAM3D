Writing a Plugin {#writingplugins}
=========

##  Introduction
Creating a plugin for the DREAM.3D Application involves many different types of files being created and being placed in the correct positions in the project directory. To alleviate the developer of the tedious task of creating all of these files there is a shortcut that has been written using the CMake build system. Nicely enough there is a **PluginMaker** application that the developer can Launch and fill in a few text fields and then have all the files generated with skeleton source code. This minimal set of files will compile with DREAM3D but will have no functionality. The developer now needs to add their own algorithms to filter the results and produce what they need.


![PluginMaker Application](Images/PluginMaker.png)


Now that we have the plugin files ready to go we need to tell the DREAM.3D build system where to find the new plugin. Go back to CMake-GUI.app/CMake-GUI.exe/ccmake and set the **DREAM3D_EXTRA_PLUGINS** cmake variable to have the name of your plugin. This is the same name you gave it in the **PluginMaker** application. If you are building multiple extra plugins then use a semi-colon ";" to separate each plugin name. You may have to tell CMake where the source directory is for the new plugin at which point you will be prompted to enter that path into CMake.

Keep configuring until all the errors are gone and no new CMake variables appear. Once that is complete click the "Generate" button (in the CMake-GUI) or press the "g" key in ccmake to generate the project files.

Once the project files are created you can open your project and start coding your filter.

## Filter Methods to Implement

The plugin will create a single filter by default with the same name as your Plugin. Open the .cpp file which should be located at {PluginName}/Code/Filters/{PluginName}Filter.cpp.

Once this file is open there are some areas that you need to pay attention to:

### Filter Options

If you need to get some input from the user then you need to create one or more filter options. The proper place for this code is in the _setupFilterOptions();_ method. Some basic code has been generated for you that is commented out. The following enumerations are available to describe the types of options that can be used in the GUI

    enum WidgetType
    {
      StringWidget,
      IntWidget,
      DoubleWidget,
      InputFileWidget,
      OutputFileWidget,
      BooleanWidget,
      IntConstrainedWidget,
      DoubleConstrainedWidget,
      ChoiceWidget,
      CustomWidget
    };

- StringWidget - This will display a Text Edit for the user to enter a string of text characters
- IntWidget - This will display a Text Edit field that only accepts integer values
- DoubleWidget - This will display a Text Edit field that only accepts floating point values
- InputFileWidget - This will display a Text Field and a button that the user can use to select a file from the local file system
- OutputFileWidget - This will display a Text Field and a button that the user can use to save a file to the local file system
- BooleanWidget - This will display a Checkbox widget to the user to mark as True or False
- IntConstrainedWidget - This is not implemented yet
- DoubleConstrainedWidget - This is not implemented yet
- ChoiceWidget - This will display a ComboBox Drop Down menu that allows the user to select from a preset list of choices

In addition a specific set of accessor methods also needs to be implmented for the specific parameter that the filter accepts. Let's take an example to work through this. Let's say that our filter needs an integer input called _Factor_ their are 2 files that need to be updated: both the .h and the .cpp file. Start by opening the .h file and just below the destructor you can use a predefined macro called _DREAM3D_INSTANCE_PROPERTY_ and it would look like the following:

    DREAM3D_INSTANCE_PROPERTY(int, Factor)

Save the .h file and now open the .cpp file.


You will want to give your option a default value by setting it in the class constructor or initializer list for the class.

Now look at the _setupFilterOptions()_ method. If you generated your plugin using the PluginMaker Application there will already be some example code in place but commented out. We need to add a _FilterOption_ so that the autogenerated Gui Widget can hook everything up. Here is the complete code for the _setupFilterOptions()_ mathod.

    void [Class Name]::setupFilterOptions()
    {
      std::vector<FilterOption::Pointer> options;
      {
        FilterOption::Pointer option = FilterOption::New();
        option->setHumanLabel("The Factor");
        option->setPropertyName("Factor");
        option->setWidgetType(FilterOption::IntWidget);
        option->setValueType("int");
        options.push_back(option);
      }
    }

Note on the line "option->setPropertyName("Factor");" that the quoted argument is the exact same as what was in the DREAM3D_INSTANCE_PROPERTY() macro in the header.

The next method to update is the _void [Class Name]::writeFilterOptions(AbstractFilterOptionsWriter* writer) _ so that your options can be properly written out to disk or HDF5 file when requested. Again, there are some example codes that are commented out but for our example our method would like the following:

    void CropVolume::writeFilterOptions(AbstractFilterOptionsWriter* writer)
    {
      writer->writeValue("Factor", getFactor() );
    }

The next method to look at is the _dataCheck()_ method. This method performs checks on the availability of needed arrays, inputs files and parameters before running the filter. There are 2 important macros that you can use to initialize local pointers to arrays that you will be accessing during your filter. There are a lot of arguments to each macro which will be explained. Continuing with our example filter, say that we want to multiply each grain ID by the "Factor" parameter we would need access the GrainID data array. For this we will use the _GET_PREREQ_DATA_ macro with 10 arguments:

    void CropVolume::dataCheck(bool preflight, size_t voxels, size_t fields, size_t ensembles)
    {
      setErrorCondition(0);
      std::stringstream ss;
      DataContainer* m = getDataContainer();
      GET_PREREQ_DATA(m, DREAM3D, CellData, GrainIds, ss, -300, int32_t, Int32ArrayType, voxels, 1)
    }

The arugments are as follows:

- **m** Variable referencing the DataContainer object
- **DREAM3D** The namespace that the "GrainIds" are store in
- **CellData** The Type of data array we are accessing (CellData, FieldData, EnsembleData)
- **GrainIds** The name of the Array (These are defined in DREAM3DLib/Common/Constants.h)
- **ss** A std::stringstream variable to push error messages into if needed.
- **-300** Some negative error code that would help users identify the error message to you
- **int32_t** The primitive type of the array (intX_t, uintX_t {x=8,16,32,64}, float, double)
- **Int32ArrayType** The type of DataArray<T> that is being useed. This should match the previous argument (IntXArrayType, UIntXArrayType {X=8,16,32,64}, FloatArrayType, DoubleArrayType)
- **voxels** This is a passed in argument and represents the total number of voxels in the array
- **1** This is the number of components in the Tuple. See the DataArray documentation for an explanation. Most are "1" but some (Euler Angles) are 3.

**Important** This macro assumes that there is an __int32_t\*__ variable defined as an private instance variable in your filter class. This macro also assumes that there is a std::string private instance variable named __m_GrainIdsArrayName__. In order to add these variables open the .h file of the filter and add a private instance variable called __m_GrainIds__.

    private:
      int32_t*   m_GrainIds;


We also need to add a public instance variable called m_GrainIdsArrayName which can be done by using another macro in the header file in the "public" section:


    DREAM3D_INSTANCE_STRING_PROPERTY(GrainIdsArrayName)

The _dataCheck()_ is called during the _preflight()_ method which is called when any parameter is changed in the GUI. The code in the _dataCheck()_ should execute quickly if at all possible.


###  Generating a Widget
As part of the build system a generic Filter Widget will be created for your filter and will be available when DREAM3D is compiled. If you have special needs for your filter then as a developer one can create a custom GUI. This is an advanced topic and not covered in this tutorial.


###  Preflight Method
The Preflight method is implemented with code that performs checks for the proper arrays being created by previous filters that your filter will need. It is typically a simple pass through to the _dataCheck(...)_ method.

###  Execute Method
The _execute()_ method is the main entry point for your filter and where you should start writing your code. Some examples of possible codes are:

### Getting the size of the volume_
    size_t dims[3] = { 0, 0, 0 };
    m->getDimensions(dims);

Where the _m_ variable is the DataContainer object that stores all the data.

When working with variables from the DataContainer such as the "CellData" arrays the programmer will be using a raw C++ pointer. It is up to the programmer to bounds check their index variables before trying to get a value from the array. For example if the programmer wanted to loop over all the values in the GrainIds array the code would be the following:

    size_t total = dims[0] * dims[1] * dims[2];
    for(size_t i = 0; i < total; ++i) {
      m_GrainIds[i] = i;
    }


This code is very safe in that we have calculated the total number of voxels and are using that information for the loop control variables. There are other types of arrays store in the Ensemble section of the DataContainer which are NOT of type DataArray. There are methods to safely cast these arrays to their appropriate type.



