Adding Unit Tests to DREAM3D {#addingunittest}
=========

When a new class is developed a unit test that thoroughly tests that class or code should be generated also. These are the basic steps to generate a test using some existing infrastructure of DREAM3D.

## Create the Test File ##

Create the source file which should have a name similar to the Class with "Test.cpp" appended to the end of the file name

## Update the Test/CMakeLists.txt File ##

You need to tell CMake that you have an additional test to compile and run. Open _DREAM3D/Test/CMakeLists.txt_ 

	# --------------------------------------------------------------------------
	# XXX Test
	# --------------------------------------------------------------------------
	add_executable(XXXXXTest XXXXTest.cpp )
	target_link_libraries(XXXXXTest DREAM3DLib)
	set_target_properties(XXXXXTest PROPERTIES FOLDER Test)
	add_test(XXXXXTest ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/XXXXXTest)

Note that if your test needs more libraries to link against to add those to the _target\_link\_Libraries_ cmake function.

## Add Any Input/Output Files Generated by Your Test ##

If your test is going to generate a file then you need to update the **TestFileLocations.h.in** file with the new code. The way this file works is to create a C++ namespace for each test and within that namespace define string constants that represent the paths to the files. CMake will use this file as a template to generate the actual **TestFileLocations.h** file that is included in each Unit test source file. A typical code looks like this:

	namespace RawBinaryReaderTest
	{
		const std::string TestDir("@MXA_TEMP_DIR@RawBinaryReaderTest");
		const std::string OutputFile("@MXA_TEMP_DIR@RawBinaryReaderTest/Output.bin");
	}

And that code should be **within** the "namespace UnitTest" code block near the top of the file. If the above code we have defined both an output directory and a single file. If you need more files or different directories one can define those here. The important bit is the use of the **@MXA_TEMP_DIR@** marker that CMake will replace with the actual path to the binary directory where all the build outputs are being placed. **KEEP YOUR OUTPUTS IN THIS DIRECTORY**.

## Basic Test File ##

A template file is provided in _DREAM3D/Test/UnitTestTemplate.cpp_ that you should make a copy and rename to what ever you have decided is going to be the name of your test. Your should then start editing this file by writing your test. There are several macros that you can use to signal a failing or passing test. Those macros can be found in _DREAM3D/Test/UnitTestSupport.hpp_


## Use of Macros in Unit Test Code to Ensure Behaviors ##


This macro is a general test that the developer can use to test logic expressions

	#define DREAM3D_REQUIRE( P )
	/* EXAMPLE 
	 Make sure i <==> j otherwise FAIL immediately
	*/
	DREAM3D_REQUIRE( (i < j) )


This example allows the developer to set each of the logic arguments

	#define DREAM3D_REQUIRED(L, Q, R)
	/* EXAMPLE 
	 Make sure i == 9 otherwise FAIL immediately
	*/
	DREAM3D_REQUIRED(i, ==, 9)


This example allows the developer to require 2 variables are NOT Equal

	#define DREAM3D_REQUIRE_NE( L, R )
	/* EXAMPLE 
	 Make sure i != j otherwise FAIL immediately
	*/
	int i = 0;
	int j = 1;
	DREAM3D_REQUIRE_NE(i, j)


This example allows the developer to require to variables are Equal

	#define DREAM3D_REQUIRE_EQUAL( L, R) 
	/* EXAMPLE 
	 Make sure i == j otherwise FAIL immediately
	*/
	int i = 5;
	int j = 5;
	DREAM3D_REQUIRE_EQUAL(i, j)



Using these macros the developer can ensure specific functionality of the target C++ class or code fragment is behaving as designed. This type of testing also ensures future changes to the code keep the same behaviors.