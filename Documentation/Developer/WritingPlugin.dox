/*!

@page writingplugin Writing a Plugin


<b>THIS IS ALL WRONG. THIS NEEDS UPDATING</b>


This is an example for writing an imaginary plugin for DREAM3D that creates an
entirely new pipeline for "CalcStats". To do this there are 2 parts to consider.
The actual implementation files that run the pipeline functions and the impementation
files that give the DREAM3D Gui the ability to execute that pipeline.

@section libAdditions DREAM3D Library Additions

We need to add some source files in several locations. The first location is in
the "Source/DREAM3D" diretory. Create a new directory called "CalcStats". Inside
of the "CalcStats" directory create 4 source files and 1 cmake file:

@li Source/DREAM3D/CalcStats/CalcStats.h
@li Source/DREAM3D/CalcStats/CalcStats.cpp
@li Source/DREAM3D/CalcStats/CalcStatsFunc.h
@li Source/DREAM3D/CalcStats/CalcStatsFunc.cpp
@li Source/DREAM3D/CalcStats/SourceList.cmake


@subsection pipeline The Pipeline Implementation Files

The CaclStats.h class should be declared in the following way:
@code
#include <MXA/Common/MXASetGetMacros.h>
#include <MXA/MXATypes.h>

#include "DREAM3D/DREAM3DConfiguration.h"
#include "DREAM3D/Common/Constants.h"
#include "DREAM3D/Common/AbstractPipeline.h"
#include "DREAM3D/CalcStats/CalcStatsFunc.h"

class DREAM3DLib_EXPORT CalcStats : public AbstractPipeline
{
public:
    MXA_SHARED_POINTERS(CalcStats);
    MXA_TYPE_MACRO(CalcStats);
    MXA_STATIC_NEW_MACRO(CalcStats);
    virtual ~CalcStats();
    virtual void execute();

  protected:
    CalcStats();

  private:
    CalcStatsFunc::Pointer m;

    CalcStats(const CalcStats&);    // Copy Constructor Not Implemented
    void operator=(const CalcStats&);  // Operator '=' Not Implemented
};
@endcode

The code inside the CalcStats.cpp file will simply be the implementation for the
constructor, destructor and the execute() method. The <tt>AbstractPipeline</tt> class
has a method named <tt>run()</tt> which sets up some variables, calls the <tt>execute()</tt>
method and then calls the <tt>pipelineFinished()</tt> method. The <tt>execute</tt>
method is pure virtual in the <tt>AbstractPipeline</tt> class as the subclass
is expected to implement that method. At this point the programmer will also need
to edit the Source/DREAM3D/CMakeLists.txt file to add a call to include the "CalcStats"
directory of files. An excerpt from the CMakeLists.txt file is shown here:

The <tt>CalcStatsFunc</tt> class can generally have whatever implementation that
you want it to have. For compatibility the programmer is urged to create a set
of smart pointers using the macros defined in the <tt>MXA/Common/MXASetGetMacros.h</tt>
file. This will make your class declaration look like the following:

@code
class DREAM3DLib_EXPORT CalcStatsFunc
{
  public:
    MXA_SHARED_POINTERS(CalcStatsFunc)
    MXA_STATIC_NEW_MACRO(CalcStatsFunc)

    virtual ~CalcStatsFunc();

  protected:
    CalcStatsFunc();

  private:
    // Copy Constructor Not Implemented
    CalcStatsFunc(const CalcStatsFunc&);
    // Operator '=' Not Implemented
    void operator=(const CalcStatsFunc&);
};
@endcode

That class declaration is a <b>minimum</b> expectation. The programmer can add
any additional methods and variables needed to fully implement their pipeline
functions or memory storage.

@subsection cmakeliststxt Additions to DREAM3DLib CMakeLists.txt File

@code
......
D3DCompileDir(SurfaceMesh)
# Add in our new Pipeline directory. The macro will include
# the "SourceList.cmake" file from that directory
D3DCompileDir(CalcStats)
@endcode

@subsection sourcelisttxt SourceList.txt file
The Contents of the <tt>SourceList.txt</tt> file is something like the following:

@code
SET (DREAM3D_CalcStats_HDRS
  ${DREAM3DLib_SOURCE_DIR}/CalcStats/CalcStats.h
  ${DREAM3DLib_SOURCE_DIR}/CalcStats/CalcStatsFunc.h
)

SET (DREAM3D_CalcStats_SRCS
  ${DREAM3DLib_SOURCE_DIR}/CalcStats/CalcStats.cpp
  ${DREAM3DLib_SOURCE_DIR}/CalcStats/CalcStatsFunc.cpp
)
cmp_IDE_SOURCE_PROPERTIES( "DREAM3DLib/CalcStats"
                           "${DREAM3D_CalcStats_HDRS}"
                           "${DREAM3D_CalcStats_SRCS}" "0")
if ( ${DREAM3D_INSTALL_FILES} EQUAL 1 )
    INSTALL (FILES ${DREAM3D_CalcStats_HDRS}
            DESTINATION include/DREAM3D/CalcStats
            COMPONENT Headers   )
endif()
@endcode

This is the only code needed to create your new pipeline and compile it into the
DREAM3D library. At this point the only way to use the new pipeline would be from
a command line application or from a GUI application without any real feedback.
This design was done on purpose so that our lower level codes are <b>NOT</b> tied
to any single GUI toolkit. All the code should be standard C or C++ codes. When
we write our GUI plugin (for Qt currently) we will add some special classes that
will wrap the functionality into classes that the GUI can use to set and get progress
feedback, cancel the pipeline, and gather inputs from the GUI and push those input
values to the Pipeline class.


@section guiplugin Creating the GUI Plugin for Qt
In order for the main DREAM3D Application to execute the new <tt>CalcStats</tt>
pipeline we need to build a new plugin for the pipeline that exposes the functionality
to the GUI. To start off we need to create a new directory:

<tt>Source/UIPlugins/CalcStats</tt> and inside that directory we will be creating
several classes based off of Qt classes and our own classes plus some support files
for our plugin such as images and icons.

@li Source/UIPlugins/CalcStats/CalcStatsPlugin.h
@li Source/UIPlugins/CalcStats/CalcStatsPlugin.cpp
@li Source/UIPlugins/CalcStats/CalcStatsWidget.h
@li Source/UIPlugins/CalcStats/CalcStatsWidget.cpp
@li Source/UIPlugins/CalcStats/CMakeLists.txt
@li Source/UIPlugins/CalcStats/CalcStats.png
@li Source/UIPlugins/CalcStats/CalcStatsWidget.ui
@li Source/UIPlugins/CalcStats/Icons.qrc

@subsection CalcStatsPlugin CalcStatsPlugin.h Implementation
 The declaration for the CalcStatsPlugin should look like the following:'
@code
#include <QtCore/QObject>
#include <QtCore/QSettings>
#include "QtSupport/DREAM3DPluginInterface.h"

class CalcStatsWidget;
class AIMPluginFrame;

class CalcStatsPlugin : public QObject,
                        public DREAM3DPluginInterface
{
    Q_OBJECT;
    Q_INTERFACES(DREAM3DPluginInterface)

  public:
    CalcStatsPlugin();
    virtual ~CalcStatsPlugin();

    QString getPluginName();
    //Returns the QWidget that gets presented to the user
    virtual QWidget* getInputWidget(QWidget* parent);
    //Returns the AIMPluginFrame object
    virtual AIMPluginFrame* getPluginFrame(QWidget* parent);
    // Tells the plugin to write it's settings to the prefs object
    virtual void writeSettings(QSettings &prefs);
    // Tells the plugin to read it's setting from the prefs object
    virtual void readSettings(QSettings &prefs);

    virtual QIcon icon();

  protected:
    CalcStatsWidget* m_InputWidget;

  private:
    CalcStatsPlugin(const CalcStatsPlugin&);
    void operator=(const CalcStatsPlugin&);
};
@endcode
Note that we inherit from both QObject and from DREAM3DPluginInterface so
that we can have both the ability to hook up signals and slots and also implement
a common plugin interface. There is more information available from the Qt documentation
regarding everything that needs to be implemented for a Qt Plugin.

@subsection CalcStatsPlugincpp CalcStatsPlugin.cpp Implementation

The actual implemenation of the Plugin class can get involved so a minimal set of
skeleton code is shown here. The programmer is urged to examine other plugin classes
for details on each method impelementation. There are a few important things that
<b>MUST</b> be implemented.

@code
Q_EXPORT_PLUGIN2(CalcStatsPlugin, CalcStatsPlugin);
@endcode

The constructor for the class should instantiate the Widget so that the DREAM3D
GUI has something to display. The Widget can be designed using QDesigner if the
programmer wants. The standard techniques for that type of development apply here.
Throughout the DREAM.3D project the original programmers have selected the
multiple-inheritance technique.
@code
CalcStatsPlugin::CalcStatsPlugin() :
m_InputWidget(NULL)
{
  m_InputWidget = new CalcStatsWidget(NULL);
}
@endcode

It is handy to have different names depending on how the plugin was built. This helps
resolve errors when debugging by knowing explicitly which plugin was loaded.
@code
QString GrainGeneratorPlugin::getPluginName()
{
#ifdef NDEBUG
  return QString("GrainGenerator");
#else
  return QString("GrainGenerator Debug");
#endif
}
@endcode

The remainder of the code can be created by examining the appropriate classes of
another plugin. The code is generally the same from plugin to plugin.


@subsection pluginCalcStatsWidgeth  CalcStatsWidget_h


@subsection pluginCalcStatsWidgetcpp CalcStatsWidget.cpp


@subsection pluginCMakeListstxt CMakeLists.txt

@subsection plugincalcstatspng calcstats.png

@subsection pluginCalcStatsWidgetui CalcStatsWidget.ui

@subsection pluginiconsqrc Icons.qrc


@subsection toplevelcmakelists Top Level CMakeLists.txt File
Do not forget to add a line to the top level CMakeLists.txt file that will include
the new UIPlugin subdirectory. This line should be added after any other existing
UIPlugin Subdirectories.

@code
add_subdirectory(${DREAM3D_SOURCE_DIR}/Source/UIPlugins/CalcStats
                 ${DREAM3D_BINARY_DIR}/UIPlugins/CalcStats)

@endcode

 */
