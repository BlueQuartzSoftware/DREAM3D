/*!

@page writingplugins Writing a Plugin


@section pluginintro Introduction
  Creating a plugin for the DREAM.3D Application involves many different types of
files being created and being placed in the correct positions in the project directory.
To alleviate the developer of the tedious task of creating all of these files there
is a shortcut that has been written using the CMake build system. Nicely enough
there is a <b>PluginMaker</b> application that the developer can Launch and fill
in a few text fields and then have all the files generated with skeleton source
code. This minimal set of files will compile with DREAM3D but will have no functionality.
The developer now needs to add their own algorithms to filter the results and
produce what they need.@n
@n

@image html PluginMaker.png "PluginMaker Application"
@image latex PluginMaker.png "PluginMaker Application" width=6in

@n
  Now that we have the plugin files ready to go we need to tell the DREAM.3D build
system where to find the new plugin. Go back to CMake-GUI.app/CMake-GUI.exe/ccmake
and set the <b>DREAM3D_EXTRA_PLUGINS</b> cmake variable to have the name of your
plugin. This is the same name you gave it in the <b>PluginMaker</b> application.
If you are building multiple extra plugins then use a semi-colon ";" to
separate each plugin name. You may have to tell CMake where the source directory
is for the new plugin at which point you will be prompted to enter that path into
CMake.

Keep configuring until all the errors are gone and no new CMake variables appear.
Once that is complete click the "Generate" button (in the CMake-GUI) or press the
"g" key in ccmake to generate the project files.

Once the project files are created you can open your project and start coding your
filter.

@section Filter_methods Filter Methods to Implement

The plugin will create a single filter by default with the same name as your Plugin.
Open the .cpp file which should be located at {PluginName}/Code/Filters/{PluginName}Filter.cpp.

Once this file is open there are some areas that you need to pay attention to:

@subsection filteroptions Filter Options

If you need to get some input from the user then you need to create one or more
filter options. The proper place for this code is in the <tt>setupFilterOptions();</tt>
method. Some basic code has been generated for you that is commented out. The
following enumerations are available to describe the types of options that can
be used in the GUI

@code
    enum WidgetType
    {
      StringWidget,
      IntWidget,
      DoubleWidget,
      InputFileWidget,
      OutputFileWidget,
      BooleanWidget,
      IntConstrainedWidget,
      DoubleConstrainedWidget,
      ChoiceWidget,
      CustomWidget
    };
@endcode

@li StringWidget - This will display a Text Edit for the user to enter a string
of text characters
@li IntWidget - This will display a Text Edit field that only accepts integer values
@li DoubleWidget - This will display a Text Edit field that only accepts floating point values
@li InputFileWidget - This will display a Text Field and a button that the user can
use to select a file from the local file system
@li OutputFileWidget - This will display a Text Field and a button that the user can
use to save a file to the local file system
@li BooleanWidget - This will display a Checkbox widget to the user to mark as True or False
@li IntConstrainedWidget - This is not implemented yet
@li DoubleConstrainedWidget - This is not implemented yet
@li ChoiceWidget - This will display a ComboBox Drop Down menu that allows the user
to select from a preset list of choices

In addition a specific set of accessor methods also needs to be implmented for the
specific parameter that the filter accepts. Let's take an example to work through this.
Let's say that our filter needs an integer input called <i>Factor</i> their are 2
files that need to be updated: both the .h and the .cpp file. Start by opening the
.h file and just below the destructor you can use a predefined macro called
<tt>DREAM3D_INSTANCE_PROPERTY</tt> and it would look like the following:

@code
    DREAM3D_INSTANCE_PROPERTY(int, Factor)
@endcode

Save the .h file and now open the .cpp file.


You will want to give your option a default value by setting it in the class
constructor or initializer list for the class.

 Now look at the <tt>setupFilterOptions()</tt>
method. If you generated your plugin using the PluginMaker Application there will
already be some example code in place but commented out. We need to add a <TT>FilterOption</TT>
so that the autogenerated Gui Widget can hook everything up. Here is the complete
code for the <tt>setupFilterOptions()</tt> mathod.
@code
void [Class Name]::setupFilterOptions()
{
  std::vector<FilterOption::Pointer> options;
  {
    FilterOption::Pointer option = FilterOption::New();
    option->setHumanLabel("The Factor");
    option->setPropertyName("Factor");
    option->setWidgetType(FilterOption::IntWidget);
    option->setValueType("int");
    options.push_back(option);
  }
}
@endcode

Note on the line "option->setPropertyName("Factor");" that the quoted argument is
the exact same as what was in the DREAM3D_INSTANCE_PROPERTY() macro in the header.

The next method to update is the <tt>void [Class Name]::writeFilterOptions(AbstractFilterOptionsWriter* writer)
</tt> so that your options can be properly written out to disk or HDF5 file when
requested. Again, there are some example codes that are commented out but for our
example our method would like the following:

@code
void CropVolume::writeFilterOptions(AbstractFilterOptionsWriter* writer)
{
  writer->writeValue("Factor", getFactor() );
}
@endcode

The next method to look at is the <tt>dataCheck()</tt> method. This method performs
checks on the availability of needed arrays, inputs files and parameters before
running the filter. There are 2 important macros that you can use to initialize
local pointers to arrays that you will be accessing during your filter. There are
a lot of arguments to each macro which will be explained. Continuing with our example
filter, say that we want to multiply each grain ID by the "Factor" parameter we would
need access the GrainID data array. For this we will use the <tt>GET_PREREQ_DATA</tt>
macro with 10 arguments:

@code
void CropVolume::dataCheck(bool preflight, size_t voxels, size_t fields, size_t ensembles)
{
  setErrorCondition(0);
  std::stringstream ss;
  DataContainer* m = getDataContainer();
  GET_PREREQ_DATA(m, DREAM3D, CellData, GrainIds, ss, -300, int32_t, Int32ArrayType, voxels, 1)
}
@endcode

The arugments are as follows:
@li <b>m</b> Variable referencing the DataContainer object
@li <b>DREAM3D</b> The namespace that the "GrainIds" are store in
@li <b>CellData</b> The Type of data array we are accessing (CellData, FieldData, EnsembleData)
@li <b>GrainIds</b> The name of the Array (These are defined in DREAM3DLib/Common/Constants.h)
@li <b>ss</b> A std::stringstream variable to push error messages into if needed.
@li <b>-300</b> Some negative error code that would help users identify the error message to you
@li <b>int32_t</b> The primitive type of the array (intX_t, uintX_t {x=8,16,32,64}, float, double)
@li <b>Int32ArrayType</b> The type of DataArray<T> that is being useed. This should match
the previous argument (IntXArrayType, UIntXArrayType {X=8,16,32,64}, FloatArrayType, DoubleArrayType)
@li <b>voxels</b> This is a passed in argument and represents the total number of voxels in the array
@li <b>1</b> This is the number of components in the Tuple. See the DataArray documentation
for an explanation. Most are "1" but some (Euler Angles) are 3.

<b>Important</b> This macro assumes that there is an <tt>int32_t*</tt> variable defined as
an private instance variable in your filter class. This macro also assumes that
there is a std::string private instance variable named <tt>m_GrainIdsArrayName</tt>.
In order to add these variables open the .h file of the filter and add a private
instance variable called m_GrainIds.
@code
  private:
     int32_t*   m_GrainIds;
@endcode

We also need to add a public instance variable called m_GrainIdsArrayName which can be done
by using another macro in the header file in the "public" section:

@code
    DREAM3D_INSTANCE_STRING_PROPERTY(GrainIdsArrayName)
@endcode


The <tt>dataCheck()</tt> is called during the <tt>preflight()</tt> method which
is called when any parameter is changed in the GUI. The code in the <tt>dataCheck()</tt>
should execute quickly if at all possible.


@subsection guigeneration Generating a Widget
 As part of the build system a generic Filter Widget will be created for your filter
and will be available when DREAM3D is compiled. If you have special needs for your
filter then as a developer one can create a custom GUI. This is an advanced topic
and not covered in this tutorial.


@subsection preflight Preflight Method
  The Preflight method is implemented with code that performs checks for the proper
arrays being created by previous filters that your filter will need. It is typically
a simple pass through to the <tt>dataCheck(...)</tt> method.

@subsection executeMethod Execute Method
  The <tt>execute()</tt> method is the main entry point for your filter and where
you should start writing your code. Some examples of possible codes are:

<i>Getting the size of the volume</i>
@code
  size_t dims[3] = { 0, 0, 0 };
  m->getDimensions(dims);
@endcode

Where the <tt>m</tt> variable is the DataContainer object that stores all the data.

When working with variables from the DataContainer such as the "CellData" arrays
the programmer will be using a raw C++ pointer. It is up to the programmer to bounds
check their index variables before trying to get a value from the array. For example
if the programmer wanted to loop over all the values in the GrainIds array the code
would be the following:

@code
size_t total = dims[0] * dims[1] * dims[2];
for(size_t i = 0; i < total; ++i) {
  m_GrainIds[i] = i;
}
@endcode
 This code is very safe in that we have calculated the total number of voxels and
are using that information for the loop control variables. There are other types
of arrays store in the Ensemble section of the DataContainer which are NOT of type
DataArray<T>. There are methods to safely cast these arrays to their appropriate type.


*/
